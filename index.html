<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>All-In-One YouTube Downloader</title>
    <meta name="description" content="Download YouTube videos and audio in various formats (MP4, WEBM, MP3, M4A) up to 4K. Features include trimming, batch downloads (info only), subtitles, metadata editing, and dark mode.">
    <meta name="keywords" content="youtube downloader, video downloader, download youtube, mp4, webm, mp3, m4a, 4k video, subtitles, youtube playlist downloader, youtube trim download">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⬇️</text></svg>">

    <style>
        /* --- PASTE YOUR EXISTING CSS HERE --- */
        /* (Keep the CSS exactly as it was in the previous version) */
        :root {
            --primary-bg: #ffffff;
            --secondary-bg: #f4f4f4;
            /* ... other variables ... */
        }
        body.dark-mode {
             --primary-bg: #1a1a1a;
             /* ... other dark mode variables ... */
        }
        /* ... all your other CSS rules ... */
         #status-message.status-error { color: var(--error-color); font-weight: bold; }
         #status-message.status-success { color: var(--success-color); font-weight: bold; }
         #status-message.status-info { opacity: 0.8; }

    </style>
</head>
<body>

    <div class="container">
        <header>
            <h1 data-lang-key="title">YouTube Downloader</h1>
             </header>
        <main>
            <section id="url-input-section" aria-labelledby="url-input-heading">
                 <input type="url" id="youtube-url" placeholder="Enter YouTube Video or Playlist URL here..." aria-required="true">
                 <span id="url-validation-message" role="alert"></span>
                 <div id="drop-zone" role="button" tabindex="0" aria-label="Drag and drop YouTube URL here">...</div>
            </section>

            <section id="results-section" aria-live="polite">
                 <div id="video-info">...</div>
                 <div id="video-preview-container" class="hidden">...</div>
                 <div id="download-options">
                     <div class="tabs" role="tablist" aria-label="Download Options">...</div>
                     <div class="tab-content active" id="video-options" role="tabpanel" aria-labelledby="video-tab-btn">
                        <div class="option-group">
                            <label for="video-quality-select" data-lang-key="qualityFormatLabel">Quality & Format:</label>
                            <select id="video-quality-select" name="video-quality">...</select>
                            <span class="file-size-estimate" id="video-file-size">~ MB</span>
                        </div>
                        <button id="show-trim-button" class="hidden" data-lang-key="trimVideoButton">Trim Video</button>
                         <div id="trim-controls">...</div>
                    </div>
                     <div class="tab-content" id="audio-options" role="tabpanel" aria-labelledby="audio-tab-btn">
                         <div class="option-group">
                            <label for="audio-quality-select" data-lang-key="qualityFormatLabel">Quality & Format:</label>
                            <select id="audio-quality-select" name="audio-quality">...</select>
                            <span class="file-size-estimate" id="audio-file-size">~ MB</span>
                        </div>
                        <button id="show-metadata-button" class="hidden" data-lang-key="editMetadataButton">Edit Metadata (ID3)</button>
                        <div id="metadata-editor">...</div>
                    </div>
                     <div class="tab-content" id="subtitles-options" role="tabpanel" aria-labelledby="subtitles-tab-btn">...</div>
                 </div>
                 <div id="batch-download-info">...</div>
                 <div id="download-action">
                    <button id="download-button" disabled data-lang-key="downloadButton">Download</button>
                    <div id="progress-container">
                        <div id="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">
                             <span id="progress-text">0%</span>
                        </div>
                    </div>
                    <p id="status-message" role="status" style="margin-top:10px; font-size: 0.9em;"></p>
                </div>
                 <div id="social-share">...</div>
            </section>
        </main>
        <footer>
             <section id="download-history" class="container">...</section>
             <p style="text-align: center; font-size: 0.8em; opacity: 0.7; margin-top: 20px; padding-bottom: 10px;">
                Disclaimer: Please respect YouTube's Terms of Service and copyright laws. Do not download copyrighted material without permission. Ensure FFMPEG is installed for trimming and audio conversion.
            </p>
        </footer>
    </div>


    <script>
        // --- Embedded JavaScript ---

        // --- Configuration & State ---
        const AppState = {
            currentVideoInfo: null, // Stores fetched video metadata
            selectedQuality: null,
            selectedFormat: 'video', // 'video', 'audio', 'subtitle'
            isPlaylist: false,
            history: [],
            currentLanguage: 'en',
            darkMode: false,
            // *** NEW: Define Backend URL ***
            backendUrl: 'http://127.0.0.1:5000' // Default Flask URL
        };

        // --- Language Strings (translations object) ---
        // --- PASTE YOUR EXISTING translations OBJECT HERE ---
        const translations = {
             en: {
                 title: "YouTube Downloader",
                 // ... all other english keys
                 downloadStatusContacting: "Contacting server...",
                 downloadStatusServerError: "Server error during download.",
                 downloadStatusReceiving: "Receiving file...",
                 fetchErrorBackend: "Error communicating with backend.",
                 fetchErrorProcessing: "Backend failed to process the URL.",
             },
             es: {
                  title: "Descargador de YouTube",
                  // ... all other spanish keys
                  downloadStatusContacting: "Contactando al servidor...",
                  downloadStatusServerError: "Error del servidor durante la descarga.",
                  downloadStatusReceiving: "Recibiendo archivo...",
                  fetchErrorBackend: "Error al comunicar con el backend.",
                  fetchErrorProcessing: "El backend no pudo procesar la URL.",
             },
              fr: {
                  title: "Téléchargeur YouTube",
                  // ... all other french keys
                  downloadStatusContacting: "Contact du serveur...",
                  downloadStatusServerError: "Erreur serveur pendant le téléchargement.",
                  downloadStatusReceiving: "Réception du fichier...",
                  fetchErrorBackend: "Erreur de communication avec le backend.",
                  fetchErrorProcessing: "Le backend n'a pas pu traiter l'URL.",
             }
             // ... other languages ...
        };


        // --- DOM Elements (Keep as before) ---
        const urlInput = document.getElementById('youtube-url');
        // --- PASTE ALL OTHER DOM ELEMENT VARIABLES HERE ---
        const validationMessage = document.getElementById('url-validation-message');
        const dropZone = document.getElementById('drop-zone');
        const resultsSection = document.getElementById('results-section');
        const videoInfoDiv = document.getElementById('video-info');
        const thumbnailImg = document.getElementById('thumbnail');
        const videoTitleH2 = document.getElementById('video-title');
        const channelNameP = document.getElementById('channel-name');
        const videoDurationP = document.getElementById('video-duration');
        const previewContainer = document.getElementById('video-preview-container');
        const videoPreview = document.getElementById('video-preview');
        const downloadOptionsDiv = document.getElementById('download-options');
        const tabButtons = document.querySelectorAll('.tab-button');
        const tabContents = document.querySelectorAll('.tab-content');
        const videoQualitySelect = document.getElementById('video-quality-select');
        const audioQualitySelect = document.getElementById('audio-quality-select');
        const subtitleSelect = document.getElementById('subtitle-select');
        const videoFileSizeSpan = document.getElementById('video-file-size');
        const audioFileSizeSpan = document.getElementById('audio-file-size');
        const subtitleFileSizeSpan = document.getElementById('subtitle-file-size');
        const showTrimButton = document.getElementById('show-trim-button');
        const trimControlsDiv = document.getElementById('trim-controls');
        const trimStartInput = document.getElementById('trim-start');
        const trimEndInput = document.getElementById('trim-end');
        const showMetadataButton = document.getElementById('show-metadata-button');
        const metadataEditorDiv = document.getElementById('metadata-editor');
        const filenameInput = document.getElementById('filename-input');
        const id3TitleInput = document.getElementById('id3-title');
        const id3ArtistInput = document.getElementById('id3-artist');
        const id3AlbumInput = document.getElementById('id3-album');
        const downloadButton = document.getElementById('download-button');
        const progressContainer = document.getElementById('progress-container');
        const progressBar = document.getElementById('progress-bar');
        const progressText = document.getElementById('progress-text');
        const statusMessage = document.getElementById('status-message');
        const batchInfoDiv = document.getElementById('batch-download-info');
        const playlistVideoCountSpan = document.getElementById('playlist-video-count');
        const historyListUl = document.getElementById('history-list');
        const clearHistoryButton = document.getElementById('clear-history-button');
        const themeToggleButton = document.getElementById('theme-toggle');
        const languageSelector = document.getElementById('language-selector');


        // --- Utility Functions (Keep _, updateUILanguage, changeLanguage, toggleTheme, updateThemeToggleButtonText, validateUrl, updateValidationMessage, generateFilename, etc. AS BEFORE) ---
        function _(key) { /* ... AS BEFORE ... */
             const lang = AppState.currentLanguage;
             return translations[lang]?.[key] || translations.en[key] || key;
        }
        function updateUILanguage() { /* ... AS BEFORE ... */
             document.querySelectorAll('[data-lang-key]').forEach(el => {
                 const key = el.getAttribute('data-lang-key');
                 const translation = _(key);
                 if (el.tagName === 'INPUT' || el.tagName === 'TEXTAREA') {
                     if(el.placeholder) el.placeholder = translation;
                 } else if (el.tagName === 'OPTION' && el.value === "") {
                    // Handle placeholder options
                     el.textContent = translation;
                 } else {
                     el.textContent = translation;
                 }
             });
             updateThemeToggleButtonText();
        }
         function changeLanguage(lang) { /* ... AS BEFORE ... */
            if (translations[lang]) {
                AppState.currentLanguage = lang;
                languageSelector.value = lang; // Sync dropdown
                updateUILanguage();
                localStorage.setItem('downloaderLang', lang);
            }
         }
        function toggleTheme() { /* ... AS BEFORE ... */
            AppState.darkMode = !AppState.darkMode;
            document.body.classList.toggle('dark-mode', AppState.darkMode);
            localStorage.setItem('downloaderTheme', AppState.darkMode ? 'dark' : 'light');
            updateThemeToggleButtonText();
         }
          function updateThemeToggleButtonText() { /* ... AS BEFORE ... */
             if (AppState.darkMode) {
                 themeToggleButton.textContent = '☀️'; // Sun emoji for switching to light
                 themeToggleButton.setAttribute('aria-label', _('themeToggleDark'));
             } else {
                 themeToggleButton.textContent = '🌓'; // Moon emoji for switching to dark
                 themeToggleButton.setAttribute('aria-label', _('themeToggleLight'));
             }
         }
        function validateUrl(url) { /* ... AS BEFORE ... */
            if (!url) {
                updateValidationMessage(_('validationEnterUrl'), 'error');
                return false;
            }
            const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.?be)\/.+$/;
            if (!youtubeRegex.test(url)) {
                updateValidationMessage(_('validationInvalidUrl'), 'error');
                return false;
            }
             AppState.isPlaylist = url.includes('playlist?list=');
             updateValidationMessage(_('validationSuccess'), 'success'); // Indicate basic format is OK
             return true;
        }
        function updateValidationMessage(message, type = 'info') { /* ... AS BEFORE ... */
            validationMessage.textContent = message;
            validationMessage.className = `validation-${type}`;
             if (type === 'success' || type === 'info') {
                 setTimeout(() => {
                     if (validationMessage.textContent === message) {
                         validationMessage.textContent = '';
                         validationMessage.className = '';
                     }
                 }, 4000);
             }
        }
        function generateFilename(title) { /* ... AS BEFORE ... */
             return title.replace(/[<>:"/\\|?*\x00-\x1F]/g, '')
                       .replace(/\s+/g, '_')
                       .substring(0, 100);
         }
        function showProgressBar(show) { /* ... AS BEFORE ... */
             progressContainer.style.display = show ? 'block' : 'none';
         }
        function updateProgressBar(percentage, text = '') { /* ... AS BEFORE ... */
             const clampedPercentage = Math.max(0, Math.min(100, percentage));
             progressBar.style.width = `${clampedPercentage}%`;
             progressBar.setAttribute('aria-valuenow', clampedPercentage);
             progressText.textContent = text || `${clampedPercentage}%`;
         }
         function updateStatusMessage(message, type = 'info') { /* ... AS BEFORE ... */
             statusMessage.textContent = message;
             statusMessage.className = `status-${type}`;
             // Longer timeout for success/error
             if (type === 'success' || type === 'error') {
                 setTimeout(() => {
                     if (statusMessage.textContent === message) {
                          statusMessage.textContent = '';
                          statusMessage.className = '';
                     }
                 }, 8000);
             } else {
                  // Shorter timeout for info
                 setTimeout(() => {
                     if (statusMessage.textContent === message) {
                          statusMessage.textContent = '';
                          statusMessage.className = '';
                     }
                 }, 4000);
             }
         }
         function resetUI() { /* ... AS BEFORE ... */
            resultsSection.style.display = 'none';
            thumbnailImg.classList.add('hidden');
            thumbnailImg.src = '#';
            videoTitleH2.textContent = '';
            channelNameP.textContent = '';
            videoDurationP.textContent = '';
            previewContainer.classList.add('hidden');
            videoPreview.src = '';
            videoQualitySelect.innerHTML = `<option value="" data-lang-key="selectQualityPlaceholder">${_('selectQualityPlaceholder')}</option>`;
            audioQualitySelect.innerHTML = `<option value="" data-lang-key="selectQualityPlaceholder">${_('selectQualityPlaceholder')}</option>`;
            subtitleSelect.innerHTML = `<option value="" data-lang-key="selectSubtitlesPlaceholder">${_('selectSubtitlesPlaceholder')}</option>`;
            updateFileSizeEstimate();
            downloadButton.disabled = true;
            showProgressBar(false);
            updateStatusMessage('');
            batchInfoDiv.style.display = 'none';
            trimControlsDiv.style.display = 'none';
            metadataEditorDiv.style.display = 'none';
            showTrimButton.classList.add('hidden');
            showMetadataButton.classList.add('hidden');
            AppState.currentVideoInfo = null;
            AppState.isPlaylist = false;
            AppState.selectedQuality = null;
            activateTab('video');
         }
         function showLoadingState(isLoading) { /* ... AS BEFORE ... */
            urlInput.disabled = isLoading;
            if(isLoading) {
                downloadButton.disabled = true;
                validationMessage.textContent = _('validationFetching');
                validationMessage.className = 'validation-info';
            } else {
                 urlInput.disabled = false; // Ensure input is re-enabled
                 downloadButton.disabled = !AppState.selectedQuality;
            }
         }
         function activateTab(tabId) { /* ... AS BEFORE ... */
            let targetTabBtnId = `${tabId}-tab-btn`;
            let targetTabContentId = `${tabId}-options`;

            if(tabId.endsWith('-tab-btn')) {
                targetTabBtnId = tabId;
                targetTabContentId = tabId.replace('-tab-btn', '-options');
            } else if(tabId.endsWith('-options')) {
                 targetTabContentId = tabId;
                 targetTabBtnId = tabId.replace('-options', '-tab-btn');
            }

             AppState.selectedFormat = tabId.replace('-tab-btn','').replace('-options','').replace('subtitles', 'subtitle');

            tabButtons.forEach(button => {
                button.classList.toggle('active', button.id === targetTabBtnId);
                button.setAttribute('aria-selected', button.id === targetTabBtnId);
            });
            tabContents.forEach(content => {
                content.classList.toggle('active', content.id === targetTabContentId);
            });
            updateFileSizeEstimate();
         }


        // --- *** MODIFIED CORE FUNCTIONS *** ---

        /**
         * Fetches video metadata from the BACKEND API.
         */
        async function fetchMetadata(url) {
            resetUI();
            updateValidationMessage(_('validationFetching'), 'info');
            showLoadingState(true);

            try {
                const response = await fetch(`${AppState.backendUrl}/api/fetch_info`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ url: url })
                });

                const result = await response.json();

                if (response.ok && result.success) {
                    AppState.currentVideoInfo = result.data; // Store fetched data
                    updateUIWithMetadata(result.data);
                    updateValidationMessage('', 'info'); // Clear validation on success
                } else {
                    // Handle backend-specific errors
                    const errorMessage = result.error || _('fetchErrorProcessing');
                    updateValidationMessage(errorMessage, 'error');
                    resetUI();
                }
            } catch (error) {
                // Handle network errors or cases where backend is down
                console.error("Error fetching metadata:", error);
                updateValidationMessage(_('fetchErrorBackend'), 'error');
                resetUI();
            } finally {
                showLoadingState(false);
            }
        }

        /**
         * Updates the UI elements with the fetched metadata from backend.
         */
        function updateUIWithMetadata(data) {
            // This function remains largely the same as before,
            // but now uses the structure received from the Flask backend.
             if (!data) {
                 resetUI();
                 return;
             }

            resultsSection.style.display = 'block';
            thumbnailImg.src = data.thumbnail || 'https://via.placeholder.com/200x112.png?text=No+Thumbnail'; // Use placeholder if no thumbnail URL
            thumbnailImg.alt = `Thumbnail for ${data.title}`;
            thumbnailImg.classList.remove('hidden');
            videoTitleH2.textContent = data.title;
            channelNameP.textContent = `Channel: ${data.channel}`;
            videoDurationP.textContent = `Duration: ${data.duration}`;
            filenameInput.value = generateFilename(data.title);
            id3TitleInput.value = data.title;
            id3ArtistInput.value = data.channel;
            id3AlbumInput.value = '';

            populateQualityOptions(data.formats || [], data.subtitles || []);

            AppState.isPlaylist = data.isPlaylist;
            if (data.isPlaylist) {
                batchInfoDiv.style.display = 'block';
                playlistVideoCountSpan.textContent = data.playlistCount;
                previewContainer.classList.add('hidden'); // No preview for playlists yet
                showTrimButton.classList.add('hidden');
                trimControlsDiv.style.display = 'none';
                showMetadataButton.classList.add('hidden'); // No metadata editing for playlists yet
                 metadataEditorDiv.style.display = 'none';

            } else {
                 batchInfoDiv.style.display = 'none';
                 // Show preview player ONLY if we implement fetching a playable stream URL
                 // For now, keep it hidden as the backend doesn't provide one easily
                 previewContainer.classList.add('hidden');
                 // if (data.previewUrl) {
                 //     videoPreview.src = data.previewUrl;
                 //     previewContainer.classList.remove('hidden');
                 // } else {
                 //     previewContainer.classList.add('hidden');
                 // }
                 showTrimButton.classList.remove('hidden');
                 showMetadataButton.classList.remove('hidden');
             }

            downloadButton.disabled = true; // Disabled until a format is selected
            activateTab(AppState.selectedFormat === 'audio' ? 'audio' : (AppState.selectedFormat === 'subtitle' ? 'subtitles' : 'video'));
        }

        /**
         * Populates the select dropdowns using data from backend.
         */
        function populateQualityOptions(formats, subtitles) {
            // Clear existing options except the placeholder
            videoQualitySelect.innerHTML = `<option value="" data-lang-key="selectQualityPlaceholder">${_('selectQualityPlaceholder')}</option>`;
            audioQualitySelect.innerHTML = `<option value="" data-lang-key="selectQualityPlaceholder">${_('selectQualityPlaceholder')}</option>`;
            subtitleSelect.innerHTML = `<option value="" data-lang-key="selectSubtitlesPlaceholder">${_('selectSubtitlesPlaceholder')}</option>`;

            formats.forEach(f => {
                const option = document.createElement('option');
                // *** IMPORTANT: Value MUST be the format_id for the backend ***
                option.value = f.id;
                option.dataset.size = f.size; // Size in MB (already calculated by backend)
                option.dataset.ext = f.ext;
                option.dataset.type = f.type; // 'video' or 'audio'
                // Use the display string prepared by the backend
                option.textContent = f.format_display || `${f.quality} (${f.ext.toUpperCase()})`;

                if (f.type === 'video') {
                    videoQualitySelect.appendChild(option);
                } else if (f.type === 'audio') {
                    audioQualitySelect.appendChild(option);
                }
            });

             subtitles.forEach(s => {
                 const option = document.createElement('option');
                 // *** IMPORTANT: Value should identify the subtitle for download ***
                 // We can pass lang and ext, or reconstruct the ID if backend expects it. Let's pass lang/ext.
                 // option.value = s.id; // If backend needs the ID from fetch_info
                 option.value = JSON.stringify({ lang: s.lang, ext: s.ext }); // Pass lang/ext info
                 option.dataset.type = 'subtitle';
                 option.dataset.lang = s.lang;
                 option.dataset.ext = s.ext;
                 option.textContent = `${s.quality} (${s.format})`; // e.g., English (SRT)
                 subtitleSelect.appendChild(option);
             });

            updateFileSizeEstimate();
        }


        /**
         * Updates the displayed estimated file size based on selection.
         * Also enables/disables download button.
         */
        function updateFileSizeEstimate() {
            const videoOption = videoQualitySelect.selectedOptions[0];
            const audioOption = audioQualitySelect.selectedOptions[0];
            const subtitleOption = subtitleSelect.selectedOptions[0];

            videoFileSizeSpan.textContent = videoOption?.dataset.size ? `~${videoOption.dataset.size} MB` : '~ MB';
            audioFileSizeSpan.textContent = audioOption?.dataset.size ? `~${audioOption.dataset.size} MB` : '~ MB';
            // Subtitle size not provided by this backend example, could be added
            subtitleFileSizeSpan.textContent = '~ KB';

            AppState.selectedQuality = null; // Reset selection

            const activeTab = document.querySelector('.tab-button.active').id;
            let selectedOption = null;

             if (activeTab === 'video-tab-btn' && videoOption?.value) {
                selectedOption = videoOption;
             } else if (activeTab === 'audio-tab-btn' && audioOption?.value) {
                 selectedOption = audioOption;
             } else if (activeTab === 'subtitles-tab-btn' && subtitleOption?.value) {
                 selectedOption = subtitleOption;
             }

             if(selectedOption){
                AppState.selectedQuality = selectedOption.value; // Store the format_id or subtitle info string
             }

            downloadButton.disabled = !AppState.selectedQuality; // Enable/disable download button
        }


        /**
         * Handles the download button click - Calls the BACKEND API.
         */
        async function handleDownload() {
            if (!AppState.currentVideoInfo || !AppState.selectedQuality) {
                 updateStatusMessage("Please select a quality/format first.", "error");
                 return;
            }

            // Find the selected option element to get dataset attributes
             let selectedOptionElement = null;
             const activeTab = document.querySelector('.tab-button.active').id;
             if (activeTab === 'video-tab-btn') selectedOptionElement = videoQualitySelect.querySelector(`option[value="${AppState.selectedQuality}"]`);
             else if (activeTab === 'audio-tab-btn') selectedOptionElement = audioQualitySelect.querySelector(`option[value="${AppState.selectedQuality}"]`);
             else if (activeTab === 'subtitles-tab-btn') selectedOptionElement = subtitleSelect.querySelector(`option[value="${AppState.selectedQuality}"]`);


            if (!selectedOptionElement) {
                updateStatusMessage("Internal error: Could not find selected option details.", "error");
                return;
            }

            const formatType = AppState.selectedFormat; // 'video', 'audio', 'subtitle'
            const qualityId = AppState.selectedQuality; // The value sent to backend (format_id or subtitle info)
            const originalUrl = urlInput.value;
            const defaultExt = selectedOptionElement.dataset.ext || (formatType === 'video' ? 'mp4' : (formatType === 'audio' ? 'mp3' : 'srt'));
             // Use filename from input OR generate based on original title
             const filenameBase = filenameInput.value ? generateFilename(filenameInput.value) : generateFilename(AppState.currentVideoInfo.title);
             const finalFilenameHint = `${filenameBase}.${defaultExt}`; // Backend will determine final ext, but provide hint

            const downloadData = {
                url: originalUrl,
                qualityId: qualityId, // Send the selected format_id or subtitle info string
                type: formatType,
                filename: finalFilenameHint, // Filename hint for the backend
                trim: null,
                metadata: null,
                // isPlaylist: AppState.isPlaylist, // Backend detects this from URL
            };

            // Add trim info
            if (formatType === 'video' && !AppState.isPlaylist && trimControlsDiv.style.display !== 'none') {
                const start = trimStartInput.value.trim();
                const end = trimEndInput.value.trim();
                if (start || end) {
                    downloadData.trim = { start: start || null, end: end || null };
                }
            }

            // Add metadata
            if (formatType === 'audio' && metadataEditorDiv.style.display !== 'none') {
                downloadData.metadata = {
                    title: id3TitleInput.value.trim() || AppState.currentVideoInfo.title,
                    artist: id3ArtistInput.value.trim() || AppState.currentVideoInfo.channel,
                    album: id3AlbumInput.value.trim() || null,
                };
                 // Update filename hint if user edited the input
                 if(filenameInput.value && (generateFilename(filenameInput.value) !== generateFilename(AppState.currentVideoInfo.title))){
                     downloadData.filename = `${generateFilename(filenameInput.value)}.${defaultExt}`;
                 }
            }

            // *** START DOWNLOAD PROCESS ***
            console.log("Requesting download with data:", downloadData);
            updateStatusMessage(_('downloadStatusContacting'), 'info');
            showProgressBar(true);
            updateProgressBar(5, _('downloadStatusContacting')); // Initial small progress
            downloadButton.disabled = true;

            try {
                updateProgressBar(10, _('downloadStatusPreparing')); // Update status text
                const response = await fetch(`${AppState.backendUrl}/api/download`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(downloadData)
                });

                 updateProgressBar(30, _('downloadStatusReceiving')); // Indicate receiving starts

                if (!response.ok) {
                    // Try to get error message from backend JSON response
                    let errorMsg = _('downloadStatusServerError');
                    try {
                         const errorResult = await response.json();
                         if (errorResult && errorResult.error) {
                             errorMsg = errorResult.error;
                         }
                    } catch (e) {
                        console.warn("Could not parse error JSON from backend response.");
                    }
                     throw new Error(errorMsg); // Throw error to be caught below
                 }

                // Get filename from Content-Disposition header if available
                 let downloadFilename = finalFilenameHint; // Default
                 const disposition = response.headers.get('Content-Disposition');
                 if (disposition && disposition.indexOf('attachment') !== -1) {
                     const filenameRegex = /filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/;
                     const matches = filenameRegex.exec(disposition);
                     if (matches != null && matches[1]) {
                         downloadFilename = matches[1].replace(/['"]/g, '');
                     }
                 }

                // Handle the file blob
                const blob = await response.blob();

                 // Simulate progress during blob download (this isn't real network progress)
                 updateProgressBar(80, _('downloadStatusProcessing'));

                // Create a link to download the blob
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = downloadFilename; // Use filename from header or the hint
                document.body.appendChild(a);

                a.click(); // Trigger the download prompt

                // Clean up
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);

                updateProgressBar(100, _('downloadStatusComplete'));
                updateStatusMessage(_('downloadStatusComplete'), 'success');
                addToHistory({
                    title: AppState.currentVideoInfo.title + (AppState.isPlaylist ? ` (Playlist)` : ''),
                    url: originalUrl,
                    quality: qualityId, // Store format_id or subtitle info
                     filename: downloadFilename,
                    date: new Date().toISOString()
                });

             } catch (error) {
                 console.error("Download Error:", error);
                 updateStatusMessage(`${_('downloadStatusError')}: ${error.message}`, 'error');
                 showProgressBar(false); // Hide progress bar on error
             } finally {
                // Re-enable button after a short delay on success, immediately on error
                setTimeout(() => {
                    // Only hide progress bar if it was successful (or keep showing error %?)
                    // For simplicity, hide after success delay, keep showing on error until next action
                    if (progressBar.style.width === '100%') {
                        showProgressBar(false);
                    }
                    downloadButton.disabled = false;
                }, progressBar.style.width === '100%' ? 2000 : 500); // Longer delay on success
            }
        }


        // --- History Management (Keep loadHistory, saveHistory, addToHistory, clearHistory, renderHistory AS BEFORE) ---
        function loadHistory() { /* ... AS BEFORE ... */
             const storedHistory = localStorage.getItem('downloaderHistory');
             AppState.history = storedHistory ? JSON.parse(storedHistory) : [];
             renderHistory();
         }
         function saveHistory() { /* ... AS BEFORE ... */
             localStorage.setItem('downloaderHistory', JSON.stringify(AppState.history));
         }
         function addToHistory(item) { /* ... AS BEFORE ... */
             AppState.history.unshift(item);
             if (AppState.history.length > 50) AppState.history.pop();
             saveHistory();
             renderHistory();
         }
         function clearHistory() { /* ... AS BEFORE ... */
             AppState.history = [];
             saveHistory();
             renderHistory();
         }
        function renderHistory() { /* ... AS BEFORE ... */
            historyListUl.innerHTML = '';
            if (AppState.history.length === 0) {
                historyListUl.innerHTML = `<li data-lang-key="historyEmpty">${_('historyEmpty')}</li>`;
                clearHistoryButton.style.display = 'none';
            } else {
                clearHistoryButton.style.display = 'inline-block';
                AppState.history.forEach(item => {
                    const li = document.createElement('li');
                    const titleSpan = document.createElement('span');
                    titleSpan.className = 'history-title';
                    titleSpan.textContent = item.title || 'Unknown Title';
                    titleSpan.title = item.filename || item.title; // Show filename on hover

                    const dateSpan = document.createElement('span');
                    dateSpan.className = 'history-date';
                    try { dateSpan.textContent = new Date(item.date).toLocaleString(); } catch (e) { dateSpan.textContent = 'Invalid Date'; }

                    li.appendChild(titleSpan);
                    li.appendChild(dateSpan);
                    historyListUl.appendChild(li);
                });
            }
        }


        // --- Drag and Drop (Keep handleDragOver, handleDragLeave, handleDrop AS BEFORE) ---
        function handleDragOver(event) { /* ... AS BEFORE ... */
             event.preventDefault(); event.stopPropagation(); dropZone.classList.add('dragover');
        }
        function handleDragLeave(event) { /* ... AS BEFORE ... */
             event.preventDefault(); event.stopPropagation(); dropZone.classList.remove('dragover');
        }
         function handleDrop(event) { /* ... AS BEFORE ... */
             event.preventDefault(); event.stopPropagation(); dropZone.classList.remove('dragover');
             const droppedData = event.dataTransfer; let url = '';
             if (droppedData.items) {
                 for (let i = 0; i < droppedData.items.length; i++) {
                     if (droppedData.items[i].kind === 'string' && (droppedData.items[i].type.match('^text/uri-list') || droppedData.items[i].type.match('^text/plain'))) {
                         const item = droppedData.items[i];
                         item.getAsString((s) => {
                             if(validateUrl(s)) { urlInput.value = s; handleUrlInputChange(); }
                             else { updateValidationMessage(_('validationInvalidUrl'), 'error'); }
                         }); return;
                     } }
             } else { url = droppedData.getData('text/uri-list') || droppedData.getData('text/plain');
                 if(validateUrl(url)) { urlInput.value = url; handleUrlInputChange(); }
                 else { updateValidationMessage(_('validationInvalidUrl'), 'error'); }
             }
         }

        // --- Social Sharing (Keep share, copyLink AS BEFORE) ---
        function share(platform) { /* ... AS BEFORE ... */
             const url = encodeURIComponent(window.location.href);
             const text = encodeURIComponent(`Check out this YouTube Downloader: ${document.title}`);
             let shareUrl = '';
             switch(platform) {
                 case 'facebook': shareUrl = `https://www.facebook.com/sharer/sharer.php?u=${url}`; break;
                 case 'twitter': shareUrl = `https://twitter.com/intent/tweet?url=${url}&text=${text}`; break;
                 case 'whatsapp': shareUrl = `https://api.whatsapp.com/send?text=${text}%20${url}`; break;
                 default: return;
             }
             window.open(shareUrl, '_blank', 'noopener,noreferrer,width=600,height=400');
         }
          function copyLink() { /* ... AS BEFORE ... */
             navigator.clipboard.writeText(window.location.href).then(() => {
                 updateStatusMessage(_('shareCopied'), 'success');
             }).catch(err => { console.error('Failed to copy link: ', err); alert('Failed to copy link.'); });
         }

        // --- Event Listeners (Keep setup AS BEFORE, ensure handleUrlInputChange exists) ---
        let inputTimeout;
        function handleUrlInputChange() { // Keep this debounced handler AS BEFORE
            clearTimeout(inputTimeout);
            const url = urlInput.value.trim();
            resetUI(); // Reset UI immediately

            if (!url) {
                updateValidationMessage('', 'info');
                return;
            }
            // Basic validation happens immediately
            if (validateUrl(url)) {
                // If basic validation passes, schedule the backend call
                inputTimeout = setTimeout(() => {
                    fetchMetadata(url); // Call the MODIFIED fetchMetadata
                }, 500);
            } else {
                downloadButton.disabled = true; // Ensure download stays disabled on invalid input
            }
        }
        urlInput.addEventListener('input', handleUrlInputChange);
        urlInput.addEventListener('paste', () => setTimeout(handleUrlInputChange, 0));
        tabButtons.forEach(button => button.addEventListener('click', () => activateTab(button.id)));
        videoQualitySelect.addEventListener('change', updateFileSizeEstimate);
        audioQualitySelect.addEventListener('change', updateFileSizeEstimate);
        subtitleSelect.addEventListener('change', updateFileSizeEstimate);
        downloadButton.addEventListener('click', handleDownload); // Calls the MODIFIED handleDownload
        themeToggleButton.addEventListener('click', toggleTheme);
        languageSelector.addEventListener('change', (e) => changeLanguage(e.target.value));
        showTrimButton.addEventListener('click', () => { /* ... AS BEFORE ... */
            const isHidden = trimControlsDiv.style.display === 'none';
             trimControlsDiv.style.display = isHidden ? 'block' : 'none';
             showTrimButton.textContent = isHidden ? 'Hide Trim Options' : _('trimVideoButton');
        });
         showMetadataButton.addEventListener('click', () => { /* ... AS BEFORE ... */
             const isHidden = metadataEditorDiv.style.display === 'none';
             metadataEditorDiv.style.display = isHidden ? 'block' : 'none';
             showMetadataButton.textContent = isHidden ? 'Hide Metadata Editor' : _('editMetadataButton');
             if (isHidden && AppState.currentVideoInfo && !filenameInput.value) { filenameInput.value = generateFilename(AppState.currentVideoInfo.title); }
             if (isHidden && AppState.currentVideoInfo) { id3TitleInput.value = id3TitleInput.value || AppState.currentVideoInfo.title; id3ArtistInput.value = id3ArtistInput.value || AppState.currentVideoInfo.channel;}
         });
        dropZone.addEventListener('dragenter', handleDragOver, false);
        dropZone.addEventListener('dragover', handleDragOver, false);
        dropZone.addEventListener('dragleave', handleDragLeave, false);
        dropZone.addEventListener('drop', handleDrop, false);
         dropZone.addEventListener('click', () => urlInput.focus());
         dropZone.addEventListener('keydown', (e) => { /* ... AS BEFORE ... */
             if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); urlInput.focus(); }
        });
        clearHistoryButton.addEventListener('click', clearHistory);


        // --- Initialization (Keep init function AS BEFORE, potentially add backend URL check) ---
        function init() {
            const savedTheme = localStorage.getItem('downloaderTheme');
            AppState.darkMode = (savedTheme === 'dark');
            document.body.classList.toggle('dark-mode', AppState.darkMode);
            updateThemeToggleButtonText();

            const savedLang = localStorage.getItem('downloaderLang');
             AppState.currentLanguage = (savedLang && translations[savedLang]) ? savedLang : languageSelector.value;
            languageSelector.value = AppState.currentLanguage;
            updateUILanguage();

            loadHistory();
            resetUI();
            console.log("Downloader UI Initialized.");

            // Optional: Check if backend is reachable on load?
            // fetch(`${AppState.backendUrl}/api/ping`).then(...).catch(...)

             const urlParams = new URLSearchParams(window.location.search);
             const initialUrl = urlParams.get('url');
             if (initialUrl) { urlInput.value = initialUrl; handleUrlInputChange(); }
        }

        document.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
